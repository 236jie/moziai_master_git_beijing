# 模型保存机制说明

## 修改概述

本次修改为训练过程添加了基于**红方地面核心设施剩余数量**和**导弹消耗费用**的模型保存机制，自动保存训练过程中最好的10个模型。

## 修改的文件

1. **mozi_ai_sdk/sdfk_test/model_manager.py** (新建)
   - 模型管理器类，负责保存和管理最好的10个模型
   - 实现了模型比较、保存、删除最差模型等功能
   - 支持强制终止时自动保存当前模型

2. **mozi_ai_sdk/sdfk_test/envs/env_sdfk.py** (修改)
   - 在episode结束时计算导弹消耗数量和总费用
   - 通过extra_info传递protected_facilities和missile_consumption信息

3. **mozi_ai_sdk/sdfk_test/main_train.py** (修改)
   - 集成模型管理器
   - 在训练结束后处理结果并保存最好的模型
   - 添加信号处理确保强制终止时也能保存

## 保存标准

### 主要标准：红方地面核心设施剩余数量
- **越多越好**：剩余数量越多，模型越好
- 这是第一优先级标准

### 次要标准：导弹消耗总费用
- **越少越好**：当剩余数量相同时，消耗费用越少，模型越好
- 费用计算公式：`30 × C-400消耗数量 + 20 × HQ-9A消耗数量 + 10 × HQ-12消耗数量`

### 比较逻辑
1. 优先比较**protected_count**（红方地面核心设施剩余数量）
2. 如果protected_count相同，则比较**missile_cost**（导弹消耗总费用）
3. 只保存最好的10个模型

## 保存机制

### 1. 前十轮训练
- 前10轮训练的模型**全部保存**（如果满足基本条件）

### 2. 第十一轮及以后
- 如果当前模型比已保存的10个模型中的某个更好，则**替换最差的模型**
- 如果当前模型不如已保存的10个模型，则**不保存**

### 3. 强制终止处理
- 当训练被强制终止（Ctrl+C或kill信号）时，会自动保存当前正在训练的模型
- 通过信号处理机制实现，确保不会丢失数据

### 4. 重启训练
- 每次运行训练时，会先检查是否已有保存的模型
- 如果已有保存的模型，会加载模型信息
- 如果已保存了10个模型，新模型需要比最差的更好才会被保存
- 如果未满10个模型，新模型会直接保存

## 模型保存位置

### 保存目录
```
./best_models/
```

### 目录结构
```
best_models/
├── model_info.json                    # 模型信息文件（JSON格式）
├── rank_1_iter_XXX_protected_Y_cost_Z/  # 第1名模型
├── rank_2_iter_XXX_protected_Y_cost_Z/  # 第2名模型
├── ...
└── rank_10_iter_XXX_protected_Y_cost_Z/ # 第10名模型
```

### 模型信息文件格式
`model_info.json` 文件包含所有保存模型的信息：
```json
[
  {
    "rank": 1,
    "protected_count": 6,
    "missile_cost": 1200.0,
    "iteration": 150,
    "checkpoint_path": "./best_models/rank_1_iter_150_protected_6_cost_1200.0"
  },
  ...
]
```

## 使用方法

### 正常使用
直接运行 `main_train.py` 即可，模型保存机制会自动工作：

```bash
python mozi_ai_sdk/sdfk_test/main_train.py
```

### 查看保存的模型
1. 查看模型信息文件：
   ```bash
   cat ./best_models/model_info.json
   ```

2. 查看模型目录：
   ```bash
   ls -la ./best_models/
   ```

### 使用保存的模型
保存的模型可以直接用于评估或继续训练：
- 模型目录包含完整的Ray Tune检查点
- 可以使用 `--restore` 参数指定模型路径来继续训练
- 可以用于 `main_versus.py` 进行对战评估

## 技术细节

### 导弹消耗计算
- 在episode结束时（`done=True`），环境会计算：
  - 初始导弹数量 - 当前剩余导弹数量 = 消耗数量
  - 对每种导弹类型分别计算
  - 然后根据导弹价值计算总费用

### 模型比较算法
```python
def compare_models(model1, model2):
    # 优先比较protected_count
    if model1.protected_count > model2.protected_count:
        return model1  # model1更好
    elif model1.protected_count < model2.protected_count:
        return model2  # model2更好
    else:
        # protected_count相同，比较missile_cost
        if model1.missile_cost < model2.missile_cost:
            return model1  # model1更好（费用更少）
        else:
            return model2  # model2更好
```

### 信号处理
- 注册了 `SIGINT`（Ctrl+C）和 `SIGTERM`（kill）信号处理
- 当收到终止信号时，会保存当前训练的模型
- 确保强制终止时不会丢失数据

## 注意事项

1. **磁盘空间**：每个模型检查点可能占用较大空间，请确保有足够的磁盘空间
2. **模型数量**：默认保存最好的10个模型，可以通过修改 `ModelManager` 的 `top_k` 参数调整
3. **导弹消耗信息**：如果Ray Tune无法自动聚合环境的extra_info，导弹消耗信息可能无法获取，此时会使用默认值（0）
4. **训练中断**：虽然支持强制终止时保存，但建议正常结束训练以确保所有数据都被正确保存

## 修改后的效果

1. ✅ **自动保存最好的10个模型**：基于保护目标数量和导弹消耗费用
2. ✅ **支持强制终止保存**：即使训练被中断，也会保存当前模型
3. ✅ **支持重启训练**：可以继续之前的训练，模型信息会被正确加载
4. ✅ **集成到主训练流程**：只需运行 `main_train.py` 即可，无需额外操作
5. ✅ **详细的模型信息**：每个模型都有完整的元数据记录

## 故障排除

### 问题：模型没有被保存
- 检查 `./best_models/` 目录是否存在
- 查看训练日志，确认是否有错误信息
- 确认环境的extra_info是否正确传递了信息

### 问题：导弹消耗信息为0
- 这可能是Ray Tune版本问题，无法自动聚合环境的extra_info
- 可以查看环境的日志输出，手动验证导弹消耗信息
- 或者修改代码，从日志文件中解析导弹消耗信息

### 问题：强制终止时模型未保存
- 检查信号处理是否正确注册
- 查看是否有权限问题
- 确认checkpoint_path是否存在

## 后续改进建议

1. **实时保存**：在训练过程中实时保存模型，而不是只在训练结束后
2. **日志解析**：如果Ray无法聚合extra_info，可以从日志文件中解析导弹消耗信息
3. **更多指标**：可以添加更多评估指标，如拦截率、平均奖励等
4. **模型压缩**：可以只保存模型权重，而不是完整的检查点，以节省空间

